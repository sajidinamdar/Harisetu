from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel

from ..db import get_db
from ..models.chat import ChatSession, ChatMessage, ChatType
from ..models.user import User
from .user import get_current_user

router = APIRouter(
    prefix="/chat",
    tags=["chat"],
    responses={404: {"description": "Not found"}},
)

# Pydantic models
class ChatSessionCreate(BaseModel):
    chat_type: str
    expert_id: Optional[int] = None
    title: Optional[str] = None

class ChatMessageCreate(BaseModel):
    content: str
    language: str = "en"

class ChatMessageResponse(BaseModel):
    id: int
    session_id: int
    sender_id: Optional[int] = None
    content: str
    language: str
    is_ai_message: bool
    created_at: datetime
    
    class Config:
        orm_mode = True

class ChatSessionResponse(BaseModel):
    id: int
    user_id: int
    expert_id: Optional[int] = None
    chat_type: str
    title: Optional[str] = None
    is_active: bool
    created_at: datetime
    updated_at: datetime
    messages: List[ChatMessageResponse] = []
    
    class Config:
        orm_mode = True

# Mock AI response function (to be replaced with actual AI integration)
async def generate_ai_response(db: Session, session_id: int, user_message: str, language: str):
    # In a real implementation, this would call an AI service
    ai_response = "This is a mock AI response. In the actual implementation, this would be generated by an AI model."
    
    if language == "mr":
        ai_response = "हे एक नकली AI प्रतिसाद आहे. वास्तविक अंमलबजावणीमध्ये, हे AI मॉडेलद्वारे तयार केले जाईल."
    
    # Create AI message
    ai_message = ChatMessage(
        session_id=session_id,
        content=ai_response,
        language=language,
        is_ai_message=True
    )
    
    db.add(ai_message)
    db.commit()

# Routes
@router.post("/sessions", response_model=ChatSessionResponse)
def create_chat_session(
    session: ChatSessionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Validate chat type
    if session.chat_type not in [ChatType.AI_CHAT, ChatType.EXPERT_CHAT]:
        raise HTTPException(status_code=400, detail="Invalid chat type")
    
    # If expert chat, validate expert exists
    if session.chat_type == ChatType.EXPERT_CHAT and session.expert_id:
        expert = db.query(User).filter(User.id == session.expert_id, User.role == "expert").first()
        if not expert:
            raise HTTPException(status_code=404, detail="Expert not found")
    
    # Create session
    db_session = ChatSession(
        user_id=current_user.id,
        expert_id=session.expert_id if session.chat_type == ChatType.EXPERT_CHAT else None,
        chat_type=session.chat_type,
        title=session.title
    )
    
    db.add(db_session)
    db.commit()
    db.refresh(db_session)
    return db_session

@router.get("/sessions", response_model=List[ChatSessionResponse])
def read_chat_sessions(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Get sessions based on user role
    if current_user.role == "farmer":
        sessions = db.query(ChatSession).filter(
            ChatSession.user_id == current_user.id
        ).order_by(ChatSession.updated_at.desc()).offset(skip).limit(limit).all()
    elif current_user.role == "expert":
        sessions = db.query(ChatSession).filter(
            ChatSession.expert_id == current_user.id
        ).order_by(ChatSession.updated_at.desc()).offset(skip).limit(limit).all()
    else:
        # Officers can see all sessions
        sessions = db.query(ChatSession).order_by(
            ChatSession.updated_at.desc()
        ).offset(skip).limit(limit).all()
    
    return sessions

@router.get("/sessions/{session_id}", response_model=ChatSessionResponse)
def read_chat_session(
    session_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    session = db.query(ChatSession).filter(ChatSession.id == session_id).first()
    if session is None:
        raise HTTPException(status_code=404, detail="Chat session not found")
    
    # Check if user has permission to view this session
    if current_user.role == "farmer" and session.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this chat session")
    elif current_user.role == "expert" and session.expert_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this chat session")
    
    return session

@router.post("/sessions/{session_id}/messages", response_model=ChatMessageResponse)
def create_chat_message(
    session_id: int,
    message: ChatMessageCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    session = db.query(ChatSession).filter(ChatSession.id == session_id).first()
    if session is None:
        raise HTTPException(status_code=404, detail="Chat session not found")
    
    # Check if user has permission to send message in this session
    if current_user.role == "farmer" and session.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to send message in this chat session")
    elif current_user.role == "expert" and session.expert_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to send message in this chat session")
    
    # Create message
    db_message = ChatMessage(
        session_id=session_id,
        sender_id=current_user.id,
        content=message.content,
        language=message.language,
        is_ai_message=False
    )
    
    # Update session timestamp
    session.updated_at = datetime.utcnow()
    
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    
    # If AI chat, generate AI response in background
    if session.chat_type == ChatType.AI_CHAT:
        background_tasks.add_task(
            generate_ai_response, 
            db=db, 
            session_id=session_id, 
            user_message=message.content,
            language=message.language
        )
    
    return db_message

@router.get("/sessions/{session_id}/messages", response_model=List[ChatMessageResponse])
def read_chat_messages(
    session_id: int,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    session = db.query(ChatSession).filter(ChatSession.id == session_id).first()
    if session is None:
        raise HTTPException(status_code=404, detail="Chat session not found")
    
    # Check if user has permission to view messages in this session
    if current_user.role == "farmer" and session.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view messages in this chat session")
    elif current_user.role == "expert" and session.expert_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view messages in this chat session")
    
    messages = db.query(ChatMessage).filter(
        ChatMessage.session_id == session_id
    ).order_by(ChatMessage.created_at).offset(skip).limit(limit).all()
    
    return messages